/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.9.0 (NJsonSchema v10.6.8.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// @ts-nocheck

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    categoryGet(): Observable<CategoryResponseDto[]> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponseDto[]>;
        }));
    }

    protected processCategoryGet(response: HttpResponseBase): Observable<CategoryResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CategoryResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoryPost(body: CategoryRequestDto | undefined): Observable<CategoryResponseDto> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponseDto>;
        }));
    }

    protected processCategoryPost(response: HttpResponseBase): Observable<CategoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    categoryPut(body: CategoryRequestDto | undefined): Observable<CategoryResponseDto> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponseDto>;
        }));
    }

    protected processCategoryPut(response: HttpResponseBase): Observable<CategoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    categoryGet(id: number): Observable<CategoryResponseDto> {
        let url_ = this.baseUrl + "/api/Category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryResponseDto>;
        }));
    }

    protected processCategoryGet(response: HttpResponseBase): Observable<CategoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    categoryDelete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCategoryDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCategoryDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCategoryDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    courseGet(): Observable<CourseResponseDto[]> {
        let url_ = this.baseUrl + "/api/Course";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCourseGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCourseGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseResponseDto[]>;
        }));
    }

    protected processCourseGet(response: HttpResponseBase): Observable<CourseResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CourseResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    coursePost(body: CourseRequestDto | undefined): Observable<CourseResponseDto> {
        let url_ = this.baseUrl + "/api/Course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoursePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoursePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseResponseDto>;
        }));
    }

    protected processCoursePost(response: HttpResponseBase): Observable<CourseResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    coursePut(body: CourseRequestDto | undefined): Observable<CourseResponseDto> {
        let url_ = this.baseUrl + "/api/Course";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCoursePut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCoursePut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseResponseDto>;
        }));
    }

    protected processCoursePut(response: HttpResponseBase): Observable<CourseResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    courseGet(id: number): Observable<CourseResponseDto> {
        let url_ = this.baseUrl + "/api/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCourseGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCourseGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseResponseDto>;
        }));
    }

    protected processCourseGet(response: HttpResponseBase): Observable<CourseResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    courseDelete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Course/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCourseDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCourseDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCourseDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    tutorGet(): Observable<TutorResponseDto[]> {
        let url_ = this.baseUrl + "/api/Tutor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTutorGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTutorGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TutorResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TutorResponseDto[]>;
        }));
    }

    protected processTutorGet(response: HttpResponseBase): Observable<TutorResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TutorResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TutorResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tutorPost(body: TutorRequestDto | undefined): Observable<TutorResponseDto> {
        let url_ = this.baseUrl + "/api/Tutor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTutorPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTutorPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TutorResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TutorResponseDto>;
        }));
    }

    protected processTutorPost(response: HttpResponseBase): Observable<TutorResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TutorResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TutorResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tutorPut(body: TutorRequestDto | undefined): Observable<TutorResponseDto> {
        let url_ = this.baseUrl + "/api/Tutor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTutorPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTutorPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TutorResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TutorResponseDto>;
        }));
    }

    protected processTutorPut(response: HttpResponseBase): Observable<TutorResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TutorResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TutorResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    tutorGet(id: number): Observable<TutorResponseDto> {
        let url_ = this.baseUrl + "/api/Tutor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTutorGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTutorGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TutorResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TutorResponseDto>;
        }));
    }

    protected processTutorGet(response: HttpResponseBase): Observable<TutorResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TutorResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TutorResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    tutorDelete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Tutor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTutorDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTutorDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processTutorDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    userGet(): Observable<UserResponseDto[]> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseDto[]>;
        }));
    }

    protected processUserGet(response: HttpResponseBase): Observable<UserResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userPost(body: UserRequestDto | undefined): Observable<UserResponseDto> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseDto>;
        }));
    }

    protected processUserPost(response: HttpResponseBase): Observable<UserResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userPut(body: UserRequestDto | undefined): Observable<UserResponseDto> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseDto>;
        }));
    }

    protected processUserPut(response: HttpResponseBase): Observable<UserResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    userGet(id: number): Observable<UserResponseDto> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResponseDto>;
        }));
    }

    protected processUserGet(response: HttpResponseBase): Observable<UserResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    userDelete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUserDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    userRequestGet(): Observable<UserRequestResponseDto[]> {
        let url_ = this.baseUrl + "/api/UserRequest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRequestGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRequestGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestResponseDto[]>;
        }));
    }

    protected processUserRequestGet(response: HttpResponseBase): Observable<UserRequestResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserRequestResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userRequestPost(body: UserRequestRequestDto | undefined): Observable<UserRequestResponseDto> {
        let url_ = this.baseUrl + "/api/UserRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRequestPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRequestPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestResponseDto>;
        }));
    }

    protected processUserRequestPost(response: HttpResponseBase): Observable<UserRequestResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRequestResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userRequestPut(body: UserRequestRequestDto | undefined): Observable<UserRequestResponseDto> {
        let url_ = this.baseUrl + "/api/UserRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRequestPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRequestPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestResponseDto>;
        }));
    }

    protected processUserRequestPut(response: HttpResponseBase): Observable<UserRequestResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRequestResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    userRequestGet(id: number): Observable<UserRequestResponseDto> {
        let url_ = this.baseUrl + "/api/UserRequest/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRequestGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRequestGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestResponseDto>;
        }));
    }

    protected processUserRequestGet(response: HttpResponseBase): Observable<UserRequestResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRequestResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    userRequestDelete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserRequest/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRequestDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRequestDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUserRequestDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    userRequestCourseGet(requestId: number): Observable<UserRequestCourseResponseDto[]> {
        let url_ = this.baseUrl + "/api/UserRequestCourse/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRequestCourseGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRequestCourseGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestCourseResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestCourseResponseDto[]>;
        }));
    }

    protected processUserRequestCourseGet(response: HttpResponseBase): Observable<UserRequestCourseResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserRequestCourseResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestCourseResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userRequestCoursePost(body: UserRequestCourseCreateDto | undefined): Observable<UserRequestCourseResponseDto> {
        let url_ = this.baseUrl + "/api/UserRequestCourse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRequestCoursePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRequestCoursePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestCourseResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestCourseResponseDto>;
        }));
    }

    protected processUserRequestCoursePost(response: HttpResponseBase): Observable<UserRequestCourseResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRequestCourseResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestCourseResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    userRequestCourseDelete(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserRequestCourse/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRequestCourseDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRequestCourseDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUserRequestCourseDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

@Injectable()
export class CourseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCoursesByLevel(courseLevel: CourseLevel): Observable<CourseResponseDto[]> {
        let url_ = this.baseUrl + "/api/Course/get-courses-by-level/{courseLevel}";
        if (courseLevel === undefined || courseLevel === null)
            throw new Error("The parameter 'courseLevel' must be defined.");
        url_ = url_.replace("{courseLevel}", encodeURIComponent("" + courseLevel));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoursesByLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoursesByLevel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseResponseDto[]>;
        }));
    }

    protected processGetCoursesByLevel(response: HttpResponseBase): Observable<CourseResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CourseResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponseDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getCoursesByType(courseType: CourseType): Observable<CourseResponseDto[]> {
        let url_ = this.baseUrl + "/api/Course/get-courses-by-type/{courseType}";
        if (courseType === undefined || courseType === null)
            throw new Error("The parameter 'courseType' must be defined.");
        url_ = url_.replace("{courseType}", encodeURIComponent("" + courseType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoursesByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoursesByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseResponseDto[]>;
        }));
    }

    protected processGetCoursesByType(response: HttpResponseBase): Observable<CourseResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CourseResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponseDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getCoursesByCategory(categoryId: number): Observable<CourseResponseDto[]> {
        let url_ = this.baseUrl + "/api/Course/get-courses-by-category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoursesByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoursesByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseResponseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseResponseDto[]>;
        }));
    }

    protected processGetCoursesByCategory(response: HttpResponseBase): Observable<CourseResponseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CourseResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseResponseDto[]>(null as any);
    }
}

@Injectable()
export class UserRequestCourseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getCoursesState(body: UserRequestCourseCreateDto | undefined): Observable<UserRequestCourseResponseDto> {
        let url_ = this.baseUrl + "/api/UserRequestCourse/get-courses-state";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoursesState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoursesState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRequestCourseResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRequestCourseResponseDto>;
        }));
    }

    protected processGetCoursesState(response: HttpResponseBase): Observable<UserRequestCourseResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRequestCourseResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRequestCourseResponseDto>(null as any);
    }
}

export class CategoryRequestDto implements ICategoryRequestDto {
    id: number;
    name: string | undefined;
    description: string | undefined;

    constructor(data?: ICategoryRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CategoryRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }

    clone(): CategoryRequestDto {
        const json = this.toJSON();
        let result = new CategoryRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryRequestDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
}

export class CategoryResponseDto implements ICategoryResponseDto {
    name: string | undefined;
    description: string | undefined;

    constructor(data?: ICategoryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CategoryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }

    clone(): CategoryResponseDto {
        const json = this.toJSON();
        let result = new CategoryResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryResponseDto {
    name: string | undefined;
    description: string | undefined;
}

export enum CourseLevel {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class CourseRequestDto implements ICourseRequestDto {
    id: number;
    name: string;
    duration: number;
    type: CourseType;
    level: CourseLevel;
    price: number;
    isActive: boolean;
    categoryId: number;
    tutorId: number;

    constructor(data?: ICourseRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.duration = _data["duration"];
            this.type = _data["type"];
            this.level = _data["level"];
            this.price = _data["price"];
            this.isActive = _data["isActive"];
            this.categoryId = _data["categoryId"];
            this.tutorId = _data["tutorId"];
        }
    }

    static fromJS(data: any): CourseRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["duration"] = this.duration;
        data["type"] = this.type;
        data["level"] = this.level;
        data["price"] = this.price;
        data["isActive"] = this.isActive;
        data["categoryId"] = this.categoryId;
        data["tutorId"] = this.tutorId;
        return data;
    }

    clone(): CourseRequestDto {
        const json = this.toJSON();
        let result = new CourseRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICourseRequestDto {
    id: number;
    name: string;
    duration: number;
    type: CourseType;
    level: CourseLevel;
    price: number;
    isActive: boolean;
    categoryId: number;
    tutorId: number;
}

export class CourseResponseDto implements ICourseResponseDto {
    name: string | undefined;
    duration: number;
    type: CourseType;
    level: CourseLevel;
    isActive: boolean;
    categoryId: number;
    categoryName: string | undefined;
    tutorId: number;
    tutorName: string | undefined;

    constructor(data?: ICourseResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.duration = _data["duration"];
            this.type = _data["type"];
            this.level = _data["level"];
            this.isActive = _data["isActive"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.tutorId = _data["tutorId"];
            this.tutorName = _data["tutorName"];
        }
    }

    static fromJS(data: any): CourseResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["duration"] = this.duration;
        data["type"] = this.type;
        data["level"] = this.level;
        data["isActive"] = this.isActive;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["tutorId"] = this.tutorId;
        data["tutorName"] = this.tutorName;
        return data;
    }

    clone(): CourseResponseDto {
        const json = this.toJSON();
        let result = new CourseResponseDto();
        result.init(json);
        return result;
    }
}

export interface ICourseResponseDto {
    name: string | undefined;
    duration: number;
    type: CourseType;
    level: CourseLevel;
    isActive: boolean;
    categoryId: number;
    categoryName: string | undefined;
    tutorId: number;
    tutorName: string | undefined;
}

export enum CourseState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum CourseType {
    _0 = 0,
    _1 = 1,
}

export enum RequestState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class TutorRequestDto implements ITutorRequestDto {
    id: number;
    name: string | undefined;
    description: string | undefined;

    constructor(data?: ITutorRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TutorRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new TutorRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }

    clone(): TutorRequestDto {
        const json = this.toJSON();
        let result = new TutorRequestDto();
        result.init(json);
        return result;
    }
}

export interface ITutorRequestDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
}

export class TutorResponseDto implements ITutorResponseDto {
    name: string | undefined;
    description: string | undefined;

    constructor(data?: ITutorResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TutorResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TutorResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }

    clone(): TutorResponseDto {
        const json = this.toJSON();
        let result = new TutorResponseDto();
        result.init(json);
        return result;
    }
}

export interface ITutorResponseDto {
    name: string | undefined;
    description: string | undefined;
}

export class UserRequestCourseCreateDto implements IUserRequestCourseCreateDto {
    userRequestId: number;
    courseId: number;
    id: number | undefined;
    completionHours: number;
    courseState: CourseState;

    constructor(data?: IUserRequestCourseCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRequestId = _data["userRequestId"];
            this.courseId = _data["courseId"];
            this.id = _data["id"];
            this.completionHours = _data["completionHours"];
            this.courseState = _data["courseState"];
        }
    }

    static fromJS(data: any): UserRequestCourseCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestCourseCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRequestId"] = this.userRequestId;
        data["courseId"] = this.courseId;
        data["id"] = this.id;
        data["completionHours"] = this.completionHours;
        data["courseState"] = this.courseState;
        return data;
    }

    clone(): UserRequestCourseCreateDto {
        const json = this.toJSON();
        let result = new UserRequestCourseCreateDto();
        result.init(json);
        return result;
    }
}

export interface IUserRequestCourseCreateDto {
    userRequestId: number;
    courseId: number;
    id: number | undefined;
    completionHours: number;
    courseState: CourseState;
}

export class UserRequestCourseResponseDto implements IUserRequestCourseResponseDto {
    completionHours: number;
    courseState: CourseState;
    courseId: number;
    courseName: string | undefined;
    userRequestId: number;

    constructor(data?: IUserRequestCourseResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.completionHours = _data["completionHours"];
            this.courseState = _data["courseState"];
            this.courseId = _data["courseId"];
            this.courseName = _data["courseName"];
            this.userRequestId = _data["userRequestId"];
        }
    }

    static fromJS(data: any): UserRequestCourseResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestCourseResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["completionHours"] = this.completionHours;
        data["courseState"] = this.courseState;
        data["courseId"] = this.courseId;
        data["courseName"] = this.courseName;
        data["userRequestId"] = this.userRequestId;
        return data;
    }

    clone(): UserRequestCourseResponseDto {
        const json = this.toJSON();
        let result = new UserRequestCourseResponseDto();
        result.init(json);
        return result;
    }
}

export interface IUserRequestCourseResponseDto {
    completionHours: number;
    courseState: CourseState;
    courseId: number;
    courseName: string | undefined;
    userRequestId: number;
}

export class UserRequestDto implements IUserRequestDto {
    id: number;
    name: string | undefined;
    surename: string | undefined;
    username: string | undefined;
    password: string | undefined;
    isActive: boolean;

    constructor(data?: IUserRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surename = _data["surename"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UserRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surename"] = this.surename;
        data["username"] = this.username;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): UserRequestDto {
        const json = this.toJSON();
        let result = new UserRequestDto();
        result.init(json);
        return result;
    }
}

export interface IUserRequestDto {
    id: number;
    name: string | undefined;
    surename: string | undefined;
    username: string | undefined;
    password: string | undefined;
    isActive: boolean;
}

export class UserRequestRequestDto implements IUserRequestRequestDto {
    id: number | undefined;
    startDate: Date;
    endDate: Date;
    requestState: RequestState;
    totalHourPerWeek: number;
    creationDate: Date;
    modificationDate: Date;
    userId: number;
    courseIds: number[] | undefined;

    constructor(data?: IUserRequestRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.requestState = _data["requestState"];
            this.totalHourPerWeek = _data["totalHourPerWeek"];
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? new Date(_data["modificationDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            if (Array.isArray(_data["courseIds"])) {
                this.courseIds = [] as any;
                for (let item of _data["courseIds"])
                    this.courseIds.push(item);
            }
        }
    }

    static fromJS(data: any): UserRequestRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["requestState"] = this.requestState;
        data["totalHourPerWeek"] = this.totalHourPerWeek;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        if (Array.isArray(this.courseIds)) {
            data["courseIds"] = [];
            for (let item of this.courseIds)
                data["courseIds"].push(item);
        }
        return data;
    }

    clone(): UserRequestRequestDto {
        const json = this.toJSON();
        let result = new UserRequestRequestDto();
        result.init(json);
        return result;
    }
}

export interface IUserRequestRequestDto {
    id: number | undefined;
    startDate: Date;
    endDate: Date;
    requestState: RequestState;
    totalHourPerWeek: number;
    creationDate: Date;
    modificationDate: Date;
    userId: number;
    courseIds: number[] | undefined;
}

export class UserRequestResponseDto implements IUserRequestResponseDto {
    startDate: Date;
    endDate: Date;
    requestState: RequestState;
    totalHourPerWeek: number;
    creationDate: Date;
    modificationDate: Date;
    userName: number;
    userRequestCourses: UserRequestCourseResponseDto[] | undefined;

    constructor(data?: IUserRequestResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.requestState = _data["requestState"];
            this.totalHourPerWeek = _data["totalHourPerWeek"];
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.modificationDate = _data["modificationDate"] ? new Date(_data["modificationDate"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            if (Array.isArray(_data["userRequestCourses"])) {
                this.userRequestCourses = [] as any;
                for (let item of _data["userRequestCourses"])
                    this.userRequestCourses.push(UserRequestCourseResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRequestResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["requestState"] = this.requestState;
        data["totalHourPerWeek"] = this.totalHourPerWeek;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["modificationDate"] = this.modificationDate ? this.modificationDate.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        if (Array.isArray(this.userRequestCourses)) {
            data["userRequestCourses"] = [];
            for (let item of this.userRequestCourses)
                data["userRequestCourses"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserRequestResponseDto {
        const json = this.toJSON();
        let result = new UserRequestResponseDto();
        result.init(json);
        return result;
    }
}

export interface IUserRequestResponseDto {
    startDate: Date;
    endDate: Date;
    requestState: RequestState;
    totalHourPerWeek: number;
    creationDate: Date;
    modificationDate: Date;
    userName: number;
    userRequestCourses: UserRequestCourseResponseDto[] | undefined;
}

export class UserResponseDto implements IUserResponseDto {
    id: number;
    name: string | undefined;
    surename: string | undefined;
    username: string | undefined;
    password: string | undefined;
    isActive: boolean;

    constructor(data?: IUserResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surename = _data["surename"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UserResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surename"] = this.surename;
        data["username"] = this.username;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): UserResponseDto {
        const json = this.toJSON();
        let result = new UserResponseDto();
        result.init(json);
        return result;
    }
}

export interface IUserResponseDto {
    id: number;
    name: string | undefined;
    surename: string | undefined;
    username: string | undefined;
    password: string | undefined;
    isActive: boolean;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}